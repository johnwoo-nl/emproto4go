# EM Protocol Handler

Go library to communicate with chargers (aka [EVSEs](https://en.wikipedia.org/wiki/EVSE)) using the "EVSEMaster" app: Besen, Telestar, evseODM, Morec, Deltaco, ...

This is based on the Typescript library at [github.com/johnwoo-nl/emproto](https://github.com/johnwoo-nl/emproto), but not an exact re-implementation. Some things are different:
config setters are in the `EmEvse.EmConfig` object rather than `EmEvse` itself for cleaner separation of responsibilities; events work with Go channels rather than callback-based listeners; there are more events to listen for; et cetera.

This library was written by an actual human, not generated by an LMM.

The library was developed and tested using a Telestar EC311S. Since the other brands use the same app, it may work with them as well,
although there seem to be some subtle differences in supported datagrams and their formats/lengths. Use at your own risk. If something
doesn't work, please set the `debug` parameter to `true` when calling `createCommunicator` in order to see what data is received;  this may help in debugging.

This library is just that: a library, meant for developers to build an app that can communicate with chargers. It implements the
protocol used for communication between the charger and an app, and abstracts away some of the finer implementation specifics.
But, by itself, the library doesn't do much (although there is a small [CLI test runner](#cli-test-runner) included for some basic
testing from the command-line).

This library doesn't do any bluetooth; it is assumed that you have set up a Wi-Fi connection on your charger using the OEM app, and it is
reachable from the host where you run the library c.q. your app. Broadcast UDP packets from the charger should also be available to the library; if you
have placed your charger in a separate network or VLAN, or run the library in a docker container with network separation, then ensure
broadcast datagrams from the charger are routed to the library.
While the OEM app insists on reconnecting via bluetooth regularly, that seems to be an app issue; the charger does in fact remain fully
functional on the network once the Wi-Fi connection is correctly configured.

## Requirements

- Go 1.25 or higher.

## Installation

In your `go.mod`, require the library:

```
require github.com/johnwoo-nl/emproto4go v1.0.0
```

Then, in your code, import the library:

```go
import (
    "github.com/johnwoo-nl/emproto4go"
    "github.com/johnwoo-nl/emproto4go/types"
)
```

## Hello, world!

A simple program that discovers EVSEs on the network and prints their basic info:

```go
package main

import (
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/johnwoo-nl/emproto4go"
	"github.com/johnwoo-nl/emproto4go/types"
)

func main() {
	// Instantiate a communicator.
	var communicator types.EmCommunicator = emproto4go.CreateCommunicator("My App", false)

	// Start listening for EVSEMaster UDP datagrams.
	err := communicator.Start()
	if err != nil {
		log.Fatalf("Cannot start communicator: %v", err)
		return
	}

	// Make the communicator stop when main() exits.
	defer communicator.Stop()

	// Create a channel to receive events.
	eventChan := make(chan types.EmEvent, 10)

	// Watch all event types (nil as first param means watch all EVSEs, empty slice as 2nd param means all event types).
	watcher := communicator.Watch(nil, []types.EmEventType{}, eventChan)

	// Make the watcher stop when main() exits.
	defer watcher.Stop()

	// Goroutine to handle/log received events
	go func() {
		for event := range eventChan {
			if event.Type == types.EvseInfoUpdated {
				log.Printf("[%v] Evse=%+v, Info=%+v", event.Type, event.Evse, event.Evse.Info())
			} else if event.Type == types.EvseStateUpdated {
				log.Printf("[%v] Evse=%+v, State=%+v", event.Type, event.Evse, event.Evse.State())
			} else if event.Type == types.EvseChargeUpdated {
				log.Printf("[%v] Evse=%+v, Charge=%+v", event.Type, event.Evse, event.Evse.Charge())
			} else if event.Type == types.EvseConfigUpdated {
				log.Printf("[%v] Evse=%+v, Config=%+v", event.Type, event.Evse, event.Evse.Config())
			} else {
				log.Printf("[%v] Evse=%+v", event.Type, event.Evse)
			}
		}
	}()

	// Wait for interrupt signal to do a graceful shutdown.
	signalChan := make(chan os.Signal, 1)
	signal.Notify(signalChan, os.Interrupt, syscall.SIGTERM)
	log.Println("Press Ctrl+C to exit.")
	<-signalChan
	log.Println("Stopping...")
}
```

## Library usage

### EmCommunicator

The `EmCommunicator` interface is the entry point to the library, keeping track of EVSE instances and communicating over the network.
You can create a communicator instance using the `createCommunicator` factory function exported by the `main.go` library index file.

```go
communicator.Start()
// Starts listening for EVSEMaster UDP datagrams on the network, and communicating with EVSEs.
// Start can return an error if there's a problem setting up the UDP socket.
// If Start succeeds, you should call Stop to gracefully shut down the UDP socket and listener goroutine.

communicator.Stop()
// Stops listening for EVSEMaster UDP datagrams and closes the UDP socket.

communicator.GetEvses()
// Returns a slice of all known EVSEs. Initially, this will be empty until EVSEs are discovered on the network or are predefined manually via `DefineEvse`.

communicator.GetEvse(serial EmSerial)
// Returns a single EVSE by its serial number, or nil if no such EVSE is known.

communicator.DefineEvse(serial EmSerial)
// Predefines an EVSE with given serial number, so GetEvse will return it even before it's discovered on the network.
// This is useful if you know the serial numbers of your EVSEs in advance, and it is offline, or you want to set its password before it is discovered.
// If an EVSE already exists with the given serial, that existing instance is returned.
// If you set a password for such a predefined EVSE, the communicator will automatically try to log in to it once it is discovered on the network:
communicator.DefineEvse("123456789ABCDEF").UsePassword("123456")

communicator.Watch(evse EmEvse, eventTypes []EmEventType, channel chan<- EmEvent) EmEventWatcher
// Starts a watcher listening for events from either one specified EVSE, or all EVSEs.
```

### EmEvse

The `EmEvse` interface represents a single charger and exposes the functionality to read and interact with it.
You can obtain `EmEvse` instances from the communicator using `GetEvses`, `GetEvse`, `DefineEvse`, or by listening for events.

#### Getting EVSE basic info

```go
// Check if EVSE is currently online.
evse.IsOnline()

// Check if the communicator is logged in to the EVSE.
evse.IsLoggedIn()

// Get the EVSE's serial.
evse.Serial()

// Get a human-readable string label for the EVSE.
// This will be, in order of data availability:
// 1. configured name (only available after login);
// 2. brand + model (only available if online);
// 3. serial (always available, even available when predefined).
evse.Label()

// Get basic info about the EVSE.
info := evse.Info()
// info is of type EmEvseInfo, which provides following data:
info.Brand()    // Manufacturer brand.
info.Model()    // Model name/number.
info.HardwareVersion() // Hardware version.
info.SoftwareVersion() // Software version (only available after login).
info.Phases()    // 1 or 3.
info.CanForceSinglePhase() // Whether the EVSE supports forcing 1P charging when connected on 3P (only available after login).
info.MaxPower() // Maximum total supported output power in Watts.
info.MaxCurrent() // Maximum supported output current on each phase in Amps.

// To fetch/update the info from the EVSE (only when online):
info.Fetch()
```

#### Logging in

```go
// Use the same 6-digit password as for the OEM app.
// If the EVSE is online, this will attempt to log in immediately, and can throw an error if the password is incorrect (if it
// is correct, it will be kept in memory for further logins should the session be lost).
// If the EVSE is only defined, the communicator will automatically try to log in once it is discovered on the network.
err := evse.UsePassword("123456")

// Note: upon successful login, the communicator will request the EVSE's configuration.
```

#### Reading EVSE status

Once logged in, the EVSE will start sending us status info periodically.  After logging in,
it can take a few seconds before the first update arrives, and the state will be updated
about once every 5-10 seconds. The library checks incoming info against the current state
it has, and if anything changed, the state will be updated and an `EvseStateUpdated` event
will be fired for the EVSE.

```go
state := evse.State()
// state is of type EmEvseState, which provides following data:

state.CurrentState() // Protocol-level current state (see EmEvseCurrentState)
state.GunState() // Protocol-level gun (plug) state (see EmEvseGunState)
state.OutputState() // Protocol-level output (electricity flow) state (see EmEvseOutputState)

// Meta state: what things an app can effectively do with an EVSE depends on the above three
// protocol-level states. However, most apps won't be interested in all protocol-level state
// detail (doing many switch cases or if-else branches), and will just want to know the overall
// state of the EVSE, e.g. to display their UI or know if they can start a charge. For this
// common use case, the library exposes a meta state (computed from the above states) that is
// a single enum which gives the overall state, abstracting away the protocol-level states.
// It is expected and intended that most apps will only ever need this meta state and won't
// need to check the separate protocol-level state fields.
// Possible values: Defined / NotLoggedIn / Idle / PluggedIn / Charging / Error.
// See State() for more detailed state information.
evse.MetaState()
```

#### Electricity metering

The `EmEvseState` structure offers the current power output (across all phases) in watts, as well
as current voltages and amps per phase.

```go
state := evse.State()

state.CurrentPower()  // Current output power in Watts (across all phases).
state.L1Voltage()     // Current voltage on phase L1 in Volts.
state.L1Current()     // Current amps going through phase L1.
// Note: Voltage and Current also available for L2 and L3 phases (if applicable).

state.EnergyCounter() // Energy counter incrementing across charging sessions, in kWh (floating-point type).
// Note: EnergyCounter can be reset if the EVSE is disconnected from mains -- it is not a persistent total.
```

#### Temperature

The protocol specifies two temperature values: inner and outer.
On my Telestar, both values are set to the same value, which is the inner temperature. The OEM app also seems to
only ever use (show) the inner temperature. Expect the inner temperature to always be set; the outer temperature
could be empty, or set to the same value as the inner temperature.

The values of these fields are always in degrees Celsius; your app can consult the `Config().TemperatureUnit()`
field to check if that is the user-preferred unit, or convert to Fahrenheit for display if needed.

```go
state := evse.State()

state.InnerTemp() // Inner temperature in degrees Celsius.
state.OuterTemp() // Outer temperature in degrees Celsius.
```

#### EVSE errors

> [!NOTE]  
> The protocol specifies a 32-bit integer field for errors. The OEM app has a funny way to decode errors from this
> field: it converts the number to a binary string (of 32 zeroes and ones) and then finds the index of the first '1'
> character. And judging by the error values (mapping to a bit position in this field), it seems that this field is
> actually a bitfield that could have more than one error flag set simultaneously. The OEM app's way of decoding via
> a binary string is not just funny as the same index could be found more easily using bitwise arithmetic, but
> finding the index of the first '1' character also means that it will only ever detect the first set error,
> ignoring the rest of the bits in the 32-bit integer field.

The library instead will test each of the 32 bits and will return a slice of error codes (`EmError` values),
one for each set bit. You can test for errors by checking whether the slice isn't empty (or use the meta state which
will return `Error` if at least one error is set, i.e. the slice is not empty).

```go
state := evse.State()

// Errors list as a slice of EmError values. May this array forever remain empty.
state.Errors()
```

#### Getting configuration

`EmEvse.Config()` returns the current configuration. It is non-blocking, just returning whatever config is currently in memory.

```go
// getConfig returns the current config. It is not async and non-blocking.
config := evse.Config()
// Config is of type EmEvseConfig, which provides following data:

config.Name()            // Configured name of the EVSE.
config.TemperatureUnit() // Configured temperature unit (Celsius or Fahrenheit).
config.Language()        // Configured language (see EmLanguage enum).
config.OffLineCharge()   // Whether offline charge (charging by using only the EVSE itself, either
                         // without any authorization or using something like an RFID card) is enabled.
config.MaxCurrent()      // Configured maximum current per phase in Amps.
```

Note: config.MaxCurrent() is not actually used directly by the EVSE for charging  sessions; it seems
to just be a way to persist the user's preference on the EVSE so that various apps can share it. The
actual current limit for charging is passed as a parameter to `StartCharge()`. Your app should default
to this configured MaxCurrent when presenting the user with options to start a charging session. It
should also update this configuration field if the user changed the current limit when starting a
session, so other apps will know about it and can also use that limit.

I have read comments by people mentioning that on their EVSE, setting this field while charging _did_
change the current limit on-the-fly. On my Telestar any ongoing charging session is unaffected by
changes to this field; it only uses the value passed to `StartCharge()`. If you have an EVSE that can
change the output current on-the-fly, I'd be happy to know about it. Please send me the following fields:

Immediately after logging in, the communicator will request the config to keep itself up-to-date. If you want
to be certain that you have the current, live config, use `Config().Fetch()`. This will fetch config from the
charger if it was not fetched recently (the max-age is specified as the parameter to `Fetch`).

```go
err := evse.Config().Fetch(0) // maxAge=0 means always fetch from charger.
if err == nil {
    // Config() will now have fresh data.
}
```

#### Changing configuration

The EVSE must be online and logged in to change these configuration settings. Upon successful change, the EVSE's
config data structure will also be updated and a `ConfigUpdated` event will be emitted for the EVSE.

```go
evse.Config().SetName("My charger")
evse.Config().SetOffLineCharge(false)
evse.Config().SetTemperatureUnit(types.Celsius)
evse.Config().SetLanguage(types.English)
```

#### Starting a charging session

```go
// Define the parameters with which to start a charging session.
startParams := types.ChargeStartParams{
    MaxCurrent: 6, // Maximum current in Amps to use for this session.
}

// Start a charging session using above parameters.
result, err := evse.StartCharge(startParams)
```

`ChargeStartParams` offers several optional parameters to customize the charging session:

```go
startParams := types.ChargeStartParams{
    MaxCurrent: 6, // Maximum current in Amps to use for this session.
	ForceSinglePhase: true, // If the EVSE is 3-phase, force single-phase charging. Only works if Info().CanForceSinglePhase() is true.
	ChargeId: "ABC123", // Custom identifier for the session (max 8 ASCII characters; truncated if longer).
    UserId: "John Doe", // User name of the person to start the charge (max 16 ASCII characters; truncated if longer). Uses `AppName` as defined in communicator if not set.
	StartAt: time.Now().Add(1 * time.Hour), // Start time for delayed start (if in the future); otherwise starts immediately.
	MaxDuration: 120 * time.Minute, // Maximum duration of the session.
	MaxEnergy: KWh(12.5), // Maximum energy to charge for this session.
}
```

#### Getting info about the current charging session

```go
// If the EVSE is currently charging, this returns info about the ongoing charging session.
// If it's not charging but a session is planned, then this returns info about the planned
// session. If there is no session ongoing or planned, this returns info about the last finished
// session. Otherwise, it returns undefined.
// Note that you can use StopCharge() both to stop an ongoing session and to cancel a planned
// session.
charge := evse.Charge()

// charge is of type EmEvseCharge, which provides following data:
charge.CurrentState() // Protocol-level current state for the charge session (see EmCurrentState).
charge.ChargeId() // Identifier for this session, as specified at start time.
charge.UserId()  // User name of the person who started this session.
charge.MaxDuration() // Maximum duration for this session (nil if not limited).
charge.MaxEnergy() // Maximum energy to charge for this session (nil if not limited).
charge.MaxCurrent() // Maximum current used for this session.
charge.ChargedEnergy() // How many kWh have been charged in this session (floating point).
charge.Duration() // How long a current session is going on, or (if finished) how long it took.
charge.StartTime() // When the session was entered into the EVSE. If it is not a planned, session, this is also the actual starting time.
charge.ReservationTime() // When the session will start charging (for reservations/planned sessions).
```

#### Stopping a charging session

```go
// Define stop parameters.
stopParams := types.ChargeStopParams{
    UserId: "John Doe", // Optional: user name of the person who stopped the session (max 16 ASCII characters; truncated if longer). Uses `AppName` as defined in communicator if not set.
}

// Stop a charging session.
err := evse.StopCharge(stopParams)
````

Note: `StopCharge` will also cancel a planned charging session, if one was set using `StartAt` as an option for `StartCharge()`.

## CLI test runner

To run the CLI test runner from source:
```terminaloutput
go run cmd/clitest.go
```

To build the CLI test runner:
```terminaloutput
go build cmd/clitest.go
```

This will create an executable `clitest` in the project directory. Assuming Windows, that will be `clitest.exe`.

If you run it without arguments, it will discover EVSEs on the network and print some basic info as changes are detected. Press Ctrl+C to exit.

Add `debug` (to any command) to enable debug logging and dump incoming and outgoing datagrams (note: once logged in, you'll get more info but the EVSE's password will be present in the dumped datagrams, so don't copy-paste them to the internet).

To log in, set a password like this, specifying the serial of the EVSE you want to log in to and the 6-digit password:
```terminaloutput
clitest.exe 0123456789ABCDEF=123456
```
If logged in, you'll see more detailed info about the EVSE. Logging in is also required to start/stop charging sessions.

To start a session, use the `start=<amps>` argument, specifying the maximum amperage to use.
```terminaloutput
clitest.exe 0123456789ABCDEF=123456 start=6
```

To stop a session, use the `stop` command:
```terminaloutput
clitest.exe 0123456789ABCDEF=123456 stop
```

To output some debugging and compatibility info, use:
```terminaloutput
clitest.exe 0123456789ABCDEF=123456 compat
```
For this command, the test runner will stop after printing the info.

# IMPORTANT NOTE

The CLI runner makes it easy to quickly run start/stop commands. But each start c.q. stop will
cause both the EVSE's AC phase relays and the car's high-voltage DC contactors to engage c.q. disengage.
Doing this too often in quick succession **will wear these parts**!

The same goes for the library's `StartCharge` and `StopCharge` methods; your app should block excessive
starts and stops in short timespans.

Note that exact behavior may differ by car; some cars leave their contactors engaged for a short while (30 seconds
to a minute) after a session is stopped **normally** (using `StopCharge`, with the CP pin still connected -- not
when unplugged hot). For such cars, starting a new session before the contactors have disengaged will not cause wear,
and your app could start a new session (e.g. using a different amperage for solar charging) immediately. It will
probably still take a minute or so for that new session to ramp up to maximum current. I do not have a list of cars
with their actual behavior (which may vary by model year or even software version), you'd have to figure that out
yourself. In some cases the (dis)engagement of the contactors can be audible.
